#!/usr/bin/python3

import os
import re
import sys
import subprocess

import logging
import logging.handlers

# Create logger to log to syslog
syslogger = logging.getLogger('SysLogger')
syslogger.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address='/dev/log', facility="local1")
formatter = logging.Formatter('GIT-SERVER (hooks): %(message)s')
handler.setFormatter(formatter)
syslogger.addHandler(handler)

# Define zero variable, to match an empty sha
zero = "0000000000000000000000000000000000000000"

# Get user doing the action from environment
user = os.environ['REMOTE_USER']

print(os.environ)

# Get name of the repo being used
repo = os.path.basename(os.getcwd())

# Get information passed to the update hook
ref_name = sys.argv[1]  # refs/heads/master
old_sha = sys.argv[2]   # 12aa37ee58379c29186200f1fd92db689f53a24d
new_sha = sys.argv[3]   # b7eddb0077cae69a884c6ddc69cb18a030f0f27f

# Function to report errors to syslog in a nice way
def report_error(error_string):
    syslogger.critical(error_string)
    print('')
    print('Reporting error:')
    print('')
    print('    ' + error_string)
    print('')

# Function to find out if commit is present in a branch
def commit_in_branch(commit, branch):
    cmd = ['git', 'name-rev', '--refs='+branch, '--no-undefined', commit]
    FNULL = open(os.devnull, 'w')
    retcode = subprocess.call(cmd, stdout=FNULL, stderr=FNULL)
    return retcode == 0

# Function to find last tag
def last_tag(commit):
    cmd = ['git', 'describe', '--abbrev=0', '--tags', commit]
    FNULL = open(os.devnull, 'w')
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=FNULL)
    stdout, stderr = p.communicate()
    return stdout.decode('ascii').strip() or None

# Function to get the revision type. Useful to differentiate between
# annotated and unannotated tags
def get_rev_type(sha):
    cmd = ['git', 'cat-file', '-t', sha]
    FNULL = open(os.devnull, 'w')
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=FNULL)
    stdout, stderr = p.communicate()
    # It can return: commit, tag, delete
    return stdout.decode('ascii').strip()

# Function to get the commit sha that an annotated tag is pointing to
def get_commit_annotated_tag(sha):
    cmd = ['git', 'rev-list', '-1', sha]
    FNULL = open(os.devnull, 'w')
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=FNULL)
    stdout, stderr = p.communicate()
    return stdout.decode('ascii').strip()

# Function to get the tagger mail address from an annotated tag
# FIXME: make more robust; it can easily fail
def get_tagger_tag(sha):
    cmd = ['git', 'cat-file', 'tag', sha]
    FNULL = open(os.devnull, 'w')
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=FNULL)
    stdout, stderr = p.communicate()
    result = re.search('<(.*)>', stdout.decode('ascii'))
    return result.group(1)

# Function to check if the tagger was a commiter between
# two different tags
def commiter_between_tags(tagger, new_tag_commit, old_tag):
    # If old_tag is not None, look at the log until that tag.
    # Otherwise, look at the entire log
    if old_tag:
        cmd = ['git', 'log', '--format="%ce"', 'refs/tags/' + old_tag, new_tag_commit]
    else:
        cmd = ['git', 'log', '--format="%ce"', new_tag_commit]
    FNULL = open(os.devnull, 'w')
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=FNULL)
    stdout, stderr = p.communicate()
    email_list = stdout.decode('ascii').splitlines()

    # Check if the tagger email is present in the commits history
    for mail in email_list:
        if tagger == mail[1:-1]:
            return True
    return False

if ref_name.startswith('refs/heads/'):
    # User is trying to push to a branch.

    # Get branch_name by removing 'refs/heads/' from ref_name
    branch_name = ref_name[11:]

    # Allow pushing to 'develop' and 'master' for now
    permitted_branches = ['master', 'develop']
    if branch_name not in permitted_branches:
        # If user is creating a new branch, ban branches that
        # don't start with "scenario"
        if (old_sha == zero) and (not branch_name.startswith('scenario')):
            print("CREATING BRANCH WITH NAME '%s' IS NOT PERMITTED!" % branch_name)
            error = "create-branch-hook - User: \"%s\", Repo: \"%s\", Branch: \"%s\"" % (user, repo, branch_name)
            report_error(error)
            sys.exit(1) # Abort push

if ref_name.startswith('refs/tags/'):
    # User is trying to push a tag
    tag_name = ref_name[10:]
    rev_type = get_rev_type(new_sha)

    if rev_type == "commit":
        # User is trying to push an unannotated tag. We don't allow
        # this because we want git to have information about who is
        # creating the tags. This is only possible with annotated tags.
        print("TAGGING UNANNOTATED TAGS IS NOT PERMITTED!")
        error = "create-tag-unannotated - User: \"%s\", Repo: \"%s\", Tag: \"%s\"" % (user, repo, tag_name)
        report_error(error)
        sys.exit(1) # Abort push

    commit_tagged = get_commit_annotated_tag(new_sha)
    if not commit_in_branch(commit_tagged, "master"):
        # Ban tags that are not tagging a commit in 'master'
        print("TAGGING COMMITS NOT PRESENT IN 'master' IS NOT PERMITTED!")
        error = "create-tag-not-in-master - User: \"%s\", Repo: \"%s\", Tag: \"%s\"" % (user, repo, tag_name)
        report_error(error)
        sys.exit(1) # Abort push
    else:
        tagger = get_tagger_tag(new_sha)
        last_tag_found = last_tag(commit_tagged)
        if commiter_between_tags(tagger, commit_tagged, last_tag_found):
            # User is tagging a release where he was also a commiter
            print("TAGGING WHEN COMMITER SINCE LAST TAG IS NOT PERMITTED!")
            error = "create-tag-when-commiter - User: \"%s\", Repo: \"%s\", Tag: \"%s\"" % (user, repo, tag_name)
            report_error(error)
            sys.exit(1) # Abort push
