Immut Git client tests
======================

To use Gitflow workflow users will need to configure their git client

    SCENARIO user configures git client
    WHEN user configures git "user.name" to "User Name"
    THEN "git config" succeeded
    WHEN user configures git "user.email" to "user@domain.com"
    THEN "git config" succeeded


Gitflow workflow uses two branches. The master branch will contain
the releases history

    SCENARIO user creates master git branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND some new text in "test" file in "foo" repository
    WHEN user pushes all changes to "master" in "foo" repository
    THEN "git push" succeeded

The second branch called `develop` will be used as integration branch
for new features

    SCENARIO user creates develop git branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND a local branch "develop" branched from "master" in "foo" repository
    WHEN user pushes to "develop" in "foo" repository
    THEN "git push" succeeded

Developers will create feature branches for development

    SCENARIO user creates feature git branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND a local branch "feature-branch" branched from "develop" in "foo" repository
    WHEN user pushes to "feature-branch" in "foo" repository
    THEN "git push" succeeded

In these feature branches they will commmit and push their changes
to introduce the new feature

    SCENARIO user commits to feature git branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "feature-branch" checked out in "foo" repository
    AND some new text in "test" file in "foo" repository
    WHEN user pushes all changes to "feature-branch" in "foo" repository
    THEN "git push" succeeded

These feature branches can then be reviewed

    SCENARIO user can review feature branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "develop" checked out in "foo" repository
    WHEN user merges "feature-branch" in "foo" repository
    THEN "git merge" succeeded

Once that one feature branch passes review, it can be marged
into `develop` branch

    SCENARIO user can merge a feature branch back to develop
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "develop" checked out in "foo" repository
    AND the branch "feature-branch" is merged in "foo" repository
    WHEN user pushes to "develop" in "foo" repository
    THEN "git push" succeeded

Once the release team decides to create a release they will merge
the `develop` branch into `master`

    SCENARIO user can merge the "develop" branch into master
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "master" checked out in "foo" repository
    AND the branch "develop" is merged in "foo" repository
    WHEN user pushes to "master" in "foo" repository
    THEN "git push" succeeded

To finish with the release, the release team will also create
a tag in `master` branch after merging `develop`

    SCENARIO user can tag a release on master branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "master" checked out in "foo" repository
    AND a tag "release_01" is created in "foo" repository
    WHEN user pushes to "release_01" in "foo" repository
    THEN "git push" succeeded


Sometimes, bugs will appear in releases. In this cases a hotfix
branch is created

    SCENARIO user creates hotfix git branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND a local branch "hotfix-branch" branched from "master" in "foo" repository
    WHEN user pushes to "hotfix-branch" in "foo" repository
    THEN "git push" succeeded

The fixes needed in the release will be commited into this
hotfix branch

    SCENARIO user commits to hotfix git branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "hotfix-branch" checked out in "foo" repository
    AND some new text in "hotfix-test" file in "foo" repository
    WHEN user pushes all changes to "hotfix-branch" in "foo" repository
    THEN "git push" succeeded

The hotfix branch will be merged into `master` and into `develop once
it's ready

    SCENARIO user can merge hotfix branch into master and develop
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "master" checked out in "foo" repository
    AND the branch "hotfix-branch" is merged in "foo" repository
    WHEN user pushes to "master" in "foo" repository
    THEN "git push" succeeded

    GIVEN the branch "develop" checked out in "foo" repository
    AND the branch "hotfix-branch" is merged in "foo" repository
    WHEN user pushes to "master" in "foo" repository
    THEN "git push" succeeded

And a new Tag will be created for the new release

    SCENARIO user can tag a hotfix release on master branch
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "master" checked out in "foo" repository
    AND a tag "release_01.1" is created in "foo" repository
    WHEN user pushes to "release_01.1" in "foo" repository
    THEN "git push" succeeded

Sometimes a user might need to cherry pick (I'm not sure they would with
git flow workflow, since a change should be on its own branch).
This currently creates commits and then cherry picks them to another
branch in the same step, since this wouldn't happen 'in the wild'.

    SCENARIO user can cherry-pick a change
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND a local branch "hotfix-branch" branched from "master" in "foo" repository
    AND the branch "hotfix-branch" checked out in "foo" repository
    AND some new text in "hotfix-test" file in "foo" repository
    AND user commits all changes to "hotfix-branch" in "foo" repository
    GIVEN the branch "master" checked out in "foo" repository
    WHEN new commits in "hotfix-branch" are cherry-picked into "foo" repository
    THEN "git cherry-pick" succeeded
    

A user may want more details about a specific file to find out who changed some
lines of code, and why, so that they know who to ask for further information.
Git calls this 'blame'. This scenario currently just checks the command works,
so the user creates the commit and then checks it themselves, but this should
change so that they are 'blaming' a commit they did not create (it also checks
against master at the moment).

    SCENARIO user can `git blame`
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "master" checked out in "foo" repository
    AND some new text in "blame-test" file in "foo" repository
    AND user commits all changes to "master" in "foo" repository
    WHEN user runs "git blame" on "blame-test" in "master" in "foo" repository
    THEN "git blame" succeeded

3-way merge

    SCENARIO a three-way merge works when different branches change only different things in the same file
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND the branch "master" checked out in "foo" repository
    AND multiple lines of new text in "3-way-merge-test" file in "foo" repository
    AND user commits all changes to "master" in "foo" repository
    AND a local branch "merge1-branch" branched from "master" in "foo" repository
    AND the branch "merge1-branch" checked out in "foo" repository
    AND multiple lines_2 of new text in "3-way-merge-test" file in "foo" repository
    AND user commits all changes to "merge1-branch" in "foo" repository
    AND a local branch "merge2-branch" branched from "master" in "foo" repository
    AND the branch "merge2-branch" checked out in "foo" repository
    AND multiple lines_3 of new text in "3-way-merge-test" file in "foo" repository
    AND user commits all changes to "merge2-branch" in "foo" repository
    AND the branch "master" checked out in "foo" repository
    WHEN user merges "merge2-branch" and "merge1-branch" in "foo" repository
    THEN "git merge" succeeded

Bisect
    
    SCENARIO user can bisect
    ASSUMING gitserver is running
    AND git client configured
    GIVEN a local clone of "foo" repository
    AND a local branch "scenario-debug" branched from "master" in "foo" repository
    AND the branch "scenario-debug" checked out in "foo" repository
    AND some new text in "bisect-test" file in "foo" repository
    AND user commits all changes to "scenario-debug" in "foo" repository
    AND a tag "release_bisect" is created in "foo" repository
    AND some new text in "bisect-test2" file in "foo" repository
    AND user commits all changes to "scenario-debug" in "foo" repository
    AND some new text in "bisect-test3" file in "foo" repository
    AND user commits all changes to "scenario-debug" in "foo" repository
    AND a tag "bad_bisect" is created in "foo" repository
    WHEN user bisects in "scenario-debug" in "foo" repository against tag "bad_bisect" and tag "release_bisect"
    THEN "git bisect reset" succeeded
